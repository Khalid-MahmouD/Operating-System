on virtualization CPU, we focused on a general mechanism kown as  limited direct execution (LDE).
the idea is simple:

let program run directly on the hardware; at certain point(issue a timer interrupt,system call)
OS get involved and makes sure the "right" thing happends.

OS with a little help of hardware,tries delevier an efficient virtualization;
with certain point OS maintians control over the hardware.

Efficiency and control together are two of the main goals of any modern operating system.

In virtualizing memory, we will follow the same strategy, attaining Efficiency and control.
Efficiency order hardware support, which will be a few registers then get complexed TLB, page-table support, and so on.

Control implies OS ensure no application is allowed to access any memory but its own,(check boundray), to protect OS from applications, and applications from one another, we will need help
from hardware too.

we will need VM system in term of flexibility; need program to use their address space in 
whatever way they would like, make it easier.

#How we can build and efficient Virtualization of memory? providing flexibility, control which
#memory location can access ? 

we will use besides our-general approach (LDE) hardware-base address translation address translation.

with address translation, hardware change the Virtual address provided by instruction to Physical address where acutally located,

hardware not alone could handle it and get efficiently with low-level machanism,
OS must invoked to make sure the correct location take place; Manage Memory, keep track of which
location are used and which are free; intervening to maintain control over how memory is used.

the Goal is creat a beautiful illusion: the program has its own private memory, where its own code and data reside.
behind that virtual reality ugly truth: many programs sharing memory at same time,CPU switches between running one program and the next.

with OS and hardware support turn that all to powerful, easy, useful abstraction.


15.1 Assumptions 

I) user address space must be placed contiguously in physical memory.
II)the size of address space is not too big < size of physical memory.
III)each address space exactly the same size.

we will relax them later, they seem unrealistic;

15.2 An Example

load a value from memory, increments it by three, stores the value back into the memory
C- code:
x += 3;
Assembly code (in x86 assembly):
128: movl 0x0(%ebx), %eax  ;load 0+ebx into eax
132: addl $0x03, %eax      ;add 3 to eax register
135: movl %eax, 0x0(%ebx)  ;store eax back to mem

code sequance is located at address 128,
valur of X is loacted at 15 KB (in stack);
intial value of X = 3000;

when it runs following memory accesses take place:
* fetch instruction at address 128;
* excute instruction (load from 15KB);
* fetch next instruction at address 132;
* excute this instruction( add 3);
* fetch instruction at 135
* excute this instruction (store at 15KB):


Address space(generated by process) it started at address 0 and growth to maximum of 16 KB;
all memory references the process generates with this bounds.

OS wants to place the process somewhere else in physical memory;
start with x address should not be 0;
# how this illusion of virtual address space start with 0, when in reality the address space is located at some other physical address?

OS using first slot of physical memory for itself and relocated the above process at slot starting at physical memory address 32KB;

15.3 Dynamic (Hardware-based) Relocation

we will need two hardware registers within each CPU:
base register and bound register(limit); those pair allow put address space anywhere we'd like in physical memory, make sure process
access its own address space.

each program is written and compiled as if it is load at address 0;
when it running, OS decide where in Physical memory sould be loaded and base register assigned to this value;
above we load process at physical memory at 32KB and base register sets to this value;

when ant memory referece generated by process it translated by processor by :
	Physical Address =  Virtual Address  +   Base;
8
#SOFTWARE - BASED RELOCATION 
#Covert pre-running process to  a desired offset in physical address. called loader.

Each memory reference generated by the process is a virtual address;
the hardware in turn adds the contents of the base register to this address
and the result is a physical address that can be issued to the memory system.\

Example
128: movl 0x0(%ebx), %eax
PC = 128; base = 32K = 32768; PA = 32896;
hardware fetch instruction from PA not PC ;
PC = 15KB; base = 32K = 32768l; PA = 47KB;

relocation of the address happens at runtime, and because we can move address spaces even after the process has started running, 
the technique is often referred to as dynamic relocation.


what with bounds register? 
protection, processor first chenck memory reference within bounds to make sure it legal;
above example if process generate a virtual address greater thand bounds register = 16; or negative,
the CPU will raise an exception, and the process will likely be terminated.

bounds register hold the size of address space, thus hardware checks the virtual address before adding base;
hold physical address of the end of the address space,the hardware adds base then check if it within bounds.

Example Translation
size of address space is 4KB; has been load to Physical address 16KB;
VA 0 -> PA 16KB ;
VA 1KB -> PA 17KB;
VA 3000 -> PA 19384  3000 + 1024*16;
VA 4400 -> outOfBoundry;


Track with part of Memory are not in use; so we can allocate memory to process. free list which 
simply a list of the ranges of physical memory which are not currently use.


15.4 OS Issues
there are three critical junctures where the OS must take action to implement this base-and-bounds approach to virtualizing memory.

First, he OS must take action when a process is created finding a space for its address space,
the OS have to search a data structure to find room for the new address space and then mark it used; 
with two assuptions each address space (a) smaller than the size of physical memory and (b) the same size,
considering physical memory array of slots, and track whether each on is free or use.


Second, the OS must take action when a process is terminated,reclaiming all of its memory for other processes or the OS;
puts its memory back on the free list; cleans up all associated data structures as need be.

Third, the OS must also take action when a context switch occurs.
There is only one base and bounds register on each CPU, after all, and their values differ for each running program, 
as each program is loaded at a different physical address in memory. Thus, the OS must save and restore 
the base-and-bounds pair when it switches between processes.

when OS decides to stop process, it must save value of base and bound in some pre-process structure 
PCB process control block, when OS decides resumes a running process, it must set correct valure of base and bounds for this process;


when process is stop, it is possible to move address space in memory to another location.
OS Copies address space from current location to new location,
update the saved base register to point to new location.

when process resumed its new base register is restored, and running again, instruction and data become in a new slot in memory.

access base-bound register is a privilaged. user process attempts to do so, CPU will raise exception, only in kernal mode.

if it could arbitrarily change the base register while running. Imagine it! And then
quickly flush such dark thoughts from your mind, as they are the ghastly
stuff of which nightmares are made.



