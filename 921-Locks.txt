presence of interrupts on a single process(or multiple thread excuting on multiple processors concurently).
locks, programmers annote ðŸ” source code with locks, putting them around critical sections, 
thus ensure that any such critical section excutes as if it were a single atomic instruction.


28.1 Locks: The Basic Idea

updata of a shared variable:
balance = balance + 1;

Of course, other critical sections are possible, such as adding an element to a linked list or other more complex updates to shared structures,

To use a lock, we add some code around the critical section like this:
lock_t mutex; // some globally-allocated lock â€™mutexâ€™
...
lock(&mutex);
balance = balance + 1;
unlock(&mutex);

a lock is just a variable, and to use one, you must declare a lock variable(e.g..mutex above).
lock holds tha state of the lock at any instant in time, 1ï¸âƒ£ available,(unlocked or free) no thread holds the lock,
or 2ï¸âƒ£ acquired (locked or held), and thus exactly one thread hold the lock and is in a critical section.

we could store other info. in data type as well, 
1ï¸âƒ£  which thread hold the lock, a queue for ordering lock acquisition, 
2ï¸âƒ£  all is hidden from the user of the lock.

The semantics of the lock() and unlock() routines are simple.
calling lock() routine tries to acquire the lock; if no other thread hold the lock(i.e it is free), thread will acquire the lock,
entring the critical section; thread this called the owner of the lock.

if another thread then call lock() with same variable mutex, it will not return while the lock is held by another thread;
â­•in this way, other threads are prevented from entering the critical section while the first thread that holds the lock is in there. 

once the owner calls unlock() the lock is available again.
1ï¸âƒ£ no other thread waiting for the lock, state of the lock simply changed to free.(no thread has called lock() an stuck waiting).
2ï¸âƒ£ if there are waiting threads (stuck in lock()), one of them will (eventually)  notice (or be informed of) this change of lock's state,       acqurire the lock, enter critical section.


Locks provide some minimal amount of control over scheduling to programmers.
threads created by programmer but scheduled by the OS, in any fashion OS choose.
Locks yield some of that control back to the programmer;
the programmer can guarantee that no more than a single thread can ever be active within that code.
Thus locks help transform the chaos that is traditional OS scheduling into a more controlled activity.
Ø§Ù„Ø«Ø±Ø¯Ø² Ø§Ù„Ø¨Ø±ÙˆØ¬Ø±Ø§Ù…Ø± Ù‡Ùˆ Ø§Ù„Ù„ÙŠ Ø¨ÙŠØ¹Ù…Ù„Ù‡Ø§ Ø¨Ø³ Ø¨ÙŠØªÙ… ØªØ±ØªØ¨Ù‡Ø§ Ø­Ø³Ø¨ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„
Ø§Ù„Ø§Ù‚ÙØ§Ù„ Ø¨ØªØ¶ÙŠÙ‚ ÙÙŠØªØ´ÙŠØ±Ø² Ø§Ù† Ø§Ù„Ø¨Ø±ÙˆØ¬Ø±Ø§Ù…Ø± Ù‡Ùˆ Ø§Ù„Ù„ÙŠ Ù‡ÙŠØ¹Ù…Ù„Ù‡Ø§ ÙˆÙŠÙ†Ø¸Ù…Ù‡Ø§ ÙƒÙ…Ø§Ù† Ø¨Ø­ÙŠØ« Ù…ÙÙŠØ´ ØºÙŠØ± Ø«Ø±ÙŠØ¯ ÙˆØ§Ø­Ø¯Ø© Ù‡ÙŠ Ø§Ù„Ù„ÙŠ ØªØ´ØªØºÙ„
ÙˆØ¨Ø¯Ù„ Ø§Ù„ÙÙˆØ¶ÙŠ Ø¨ØªØ§Ø¹ Ø§Ù„Ø§Ø³ÙƒÙŠØ¯ÙˆØ§Ù„Ø± Ø¨ØªØ§Ø¹ Ø§Ù„Ù†Ø¸Ø§Ù… Ù‡ÙŠØ¨Ù‚ÙŠ Ø§ÙƒØªØ± ØªØ­ÙƒÙ… Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø¨Ø±ÙˆØ¬Ø±Ø§Ù…Ø±

28.2 Pthread Locks

the name POSIX library uses for lock is a mutux, used to provide mutual exclusion between threads,
i.e., any thread in critical section, it exclude the others from entering until it has completed the section.
(we use our wrappers  that check for errors upon lock and unlock):

  pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
  Pthread_mutex_lock(&lock); // wrapper for pthread_mutex_lock()
  balance = balance + 1;
  Pthread_mutex_unlock(&lock);

we can use different locks to protect different variables, increaing concurrency:
1ï¸âƒ£ instead of one big lock that is used any time any  critical section is accessed
(a coarse-grained locking strategy),the whole package is ðŸ”’ .

2ï¸âƒ£ one will often protect different data and data structures with different locks, thus allowing more threads to be in locked code at once
(a more fine-grained approach).


28.3 Building A Lock
by now you know how lock works, but how should we build a lock?
what hardware support is needed? what OS support? how we cam build efficient lock? provide mutex at low cost?

a number of different hardware primitives have been added to the instruction sets of various computer architectures;
we don't study how implement, but we study how to use them in order to build a mutual exclusion primitive like lock.
we need to study how OS gets involved to complete the picture and enable us to build a sophisticated locking library.


28.4 Evaluating Locks
befor building any locks, we should first understand what  our goals are, and ask how to evaluate the efficacy of particular 
lock implementation.

wheather the lock deos the basic task, 
which is provide ((mutual exclusion)), does the lock work ((preventing multiple threads from entering a critical section ))?

fairness,does each thread contending for the lock get a fair shot at acquiring it once it is free?
	does any thread contending for the lock starve while doing so, thus never obtaining it?

performance, time overheads added by using lock.
no contention; single thead is running grabs and releases the lock, what overhead of doing so?
multiple threads are contending for the lock on a single CPU;
muliple CPUs involved, and threads on each contending for the lock? 
we can better understand the performance impact of using various locking techniques, as described below.


28.5 Controlling Interrupts

solution earliest solutions used to provide mutual exclusion was disable interrupts for critical sections; 
for single-processor systems.
code:
void lock() {
   DisableInterrupts();
}
void unlock() {
   EnableInterrupts();
}

by turning off interrupts (using some kind of special hardware instruction) before entering a critical section, 
we ensure that code inside critical section will not be interrupted, and will excuted as if it were atomic.(grab lock)
when we finished, we re-enable interrupts (again via a hardware instruction), and thus the program proceeds as usual.(release lock)

positive of this approach is its simplicity.
with no interrupts, a thead ensure that the code it excuted will excute and no other thread will interface with it.

The negatives, unfortunately, are many
1. requires us to allow any calling thread to perform a privileged operation (turning interrupts on and off) and thus trust that  this    facility is not abused.
 . any time we are required to trust an arbitrary program, we are probably in trouble,
   gready program could call lock() at the beginning of its excution, thus monopolize the processor;
   worse, errant or malicious program could call lock() and go into endless loop.
 . OS never gain control again, restart system as solution.
   Using interrupt disabling, requires toomuch trust in applications.

2. the approach does not work on multiprocessors.
   If multiple threads are running on different CPUs, and each try to enter the same critical section, 
   it does not matter whether interrupts are disabled; threads will be able to run on other processors, and thus
   could enter critical section.

3. this aproach can be inefficient.
   masks or unmasks interrupts tends to be excuted slowly by modern CPUs.

for these reasons, turning off interrupts is only used in limited context as mutual exclusion primitive.
for example, OS use interrupt masking to guarantee atomicity when accessing its own data structures, 
or prevent certain messy interrupt handling situation from arising.
OS trust it self to perform privilaged operations anyhow. 

ASIDE: DEKKERâ€™S AND PETERSONâ€™S ALGORITHMS
Unlike the solutions we discuss here, which use special hardware instructions and even OS support	
Dekkerâ€™s approach uses just loads and stores (assuming they are atomic with respect to each other, which was true on early hardware).

just loads and stores are used, and the idea is to ensure that two threads never enter a critical section at the same time.
int flag[2];
int turn;
void init() {
	flag[0] = flag[1] = 0; // 1->thread wants to grab lock
	turn = 0; // whose turn? (thread 0 or 1?)
}
void lock() {
	flag[self] = 1; // self: thread ID of caller
	turn = 1 - self; // make it other threadâ€™s turn
	while ((flag[1 - self] == 1) && (turn == 1 - self))
		; // spin-wait
}
void unlock() {
	flag[self] = 0; // simply undo your intent
}


28.6 Test And Set (Atomic Exchange)
disabling interrupts does not work with multiple processors, start to invent hardware support for locking.
		typedef struct __lock_t { int flag; } lock_t;

		void init(lock_t * mutex) {
		 	// 0 -> lock is available, 1 -> held
	 		mutex->flag = 0;
	
		}

		 void lock(lock_t* mutex) {
	 		while (mutex->flag == 1) // TEST the flag
		 		; // spin-wait (do nothing)
	 		mutex->flag = 1; // now SET it!

		 }

 		void unlock(lock_t* mutex) {
			 mutex->flag = 0
 		}
;---------------------------------------------------------------First Attempt: A Simple Flag

the simplest bit of hardware support to understand is what is known as a test-and-set instruction, atomic exchange.
we use simple flag variable to donate whether the lock is held or not.

in first attempt, idea quite simple: use a simple variable to indicate whether some thread has possession of a lock().

senario 1:
the first thread enters the critical section will call lock(), which tests whether the flag is equal to 1 ?(it is not, in this case),
and sets the flag to 1 to indicate that the thread now holds the lock.

finished with critical section the thread calls unlock() and clears the flag, that indicating tha lock no longer held.

senario 2:
another thread 	happens to call lock(), while that first thread in critical section, it simply spin-wait in while loop until the thread
call unlock() and clear the flag. once the first thread done so, waiting one will set the flag after get out of while loop,
and proceed into critical section.


two problems
1- correctness
2- performance
1ï¸âƒ£  correctness problem is simple to see once you get used to thinking about concurrent programming (assuming flag = 0 to begin)

		thread 1				thread2
		---------------------------------------------------
		call lock()
		while(flag == 1)
		interrupt: switch to thread 2
							call lock()
							while(flag == 1)
							flag = 1; //take it for it self!!
							interrupt: switch to thread 1
		flag = 1 //take it too!
;--------------------------------------Table 28.1: Trace: No Mutual Exclusion


where both threads set their flags to 1 and both threads are thus able to enter the critical section. This is bad! We
have obviously failed to provide the most basic requirement: providing mutual exclusion.

2ï¸âƒ£ the performance problem, thread waits to acquire a lock that is already held: checking the value of flag, technique known as spin-   	waiting. and that  technique wastes timewaiting for another thread to release a lock.

3ï¸âƒ£ on uniporcessor, the wast is high, where the thread that the waiter is waiting for can not even run, so moving forward and develop more 
sophisticated solution,we should also consider ways to avoid this kind of waste.


28.7 Building A Working Spin Lock
it is not possible to implement without some support from the hardware.
some systems provide an instruction to support the creation of simple locks based on this concept.
more powerful instruction  it is the load/store unsigned byte instruction (ldstub), whereas on x86,

xchg instruction but basically does the same thing across platforms, referred to as test-and-set.

int TestAndSet(int* ptr, int new) {
	 int old = *ptr; // fetch old value at ptr
	 * ptr = new; // store â€™newâ€™ into ptr
	 return old; // return the old value
	
}
return old valure pointed by ptr, and update said value to new. the sequance of operation is performed atomically.
call test-and-set enables  you to test the old value, and setting the memory location to new value.

more powerful instruction is enough to build a simple spin lock, as we now examine in Figure 28.2

typedef struct __lock_t {
	 int flag;
	
} lock_t;

void init(lock_t * lock) {
	 // 0 indicates that lock is available, 1 that it is held
		 lock->flag = 0;
		
}

void lock(lock_t * lock) {
	while (TestAndSet(&lock->flag, 1) == 1)
		;// spin-wait (do nothing)
	
}

 void unlock(lock_t * lock) {
	 lock->flag = 0;
}
;----------------------------------------------------Figure 28.2: A Simple Spin Lock Using Test-and-set
Letâ€™s make sure we understand why this works
1st case:
1. the case where a thread calls lock() and no other thread currently holds the lock; flag should be 0.
   when thread calls TestAndSet(flag, 1), the routine return old flag which is 0; calling thread that (testing) the flag value,
   will not get caught spinning in the while loop and will acquire the lock.
   thread atomically set the value to 1, indicating that the lock is now held.
   finishing with critical section call unlock() to clear the flag = 0;

2nd case:
2. the lock held(i.e., flag is 1). thread in this case, this thread will call TestAndSet(flag, 1)as well.
   and returning the old value with is 1 (cause the lock is held). while simultaneously setting it to 1 again. 
   As long as the lock is held by another thread, TestAndSet() will repeatedly return 1, and thus this
   threadwill spin and spin until the lock is finally released. When the flag is finally set to 0 by some other thread, this thread will       call TestAndSet() again, which will now return 0 while atomically setting the value to 1 and thus acquire the lock and enter the    critical section.